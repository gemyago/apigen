
type {{>enums/model-prop-type-name}} {{^format}}{{dataType}}{{/format}}{{{format}}}

// List of {{>enums/model-prop-type-name}}
const (
	{{#allowableValues}}
	{{#enumVars}}
	{{>enums/model-prop-type-name}}{{#lambda.pascalcase}}{{{value}}}{{/lambda.pascalcase}} {{>enums/model-prop-type-name}} = {{{value}}}
	{{/enumVars}}
	{{/allowableValues}}
)

{{#allowableValues}}
{{#enumVars}}
func(v {{>enums/model-prop-type-name}}) Is{{#lambda.pascalcase}}{{{value}}}{{/lambda.pascalcase}}() bool {
  return v == {{>enums/model-prop-type-name}}{{#lambda.pascalcase}}{{{value}}}{{/lambda.pascalcase}}
}

{{/enumVars}}
{{/allowableValues}}
func(v {{{classname}}}{{name}}) String() string {
	return string(v)
}

type assignable{{>enums/model-prop-type-name}} interface {
	{{#allowableValues}}
	{{#enumVars}}
	Is{{#lambda.pascalcase}}{{{value}}}{{/lambda.pascalcase}}() bool
	{{/enumVars}}
	{{/allowableValues}}
	String() string
}

func As{{{classname}}}{{name}}(v assignable{{>enums/model-prop-type-name}}) ({{{classname}}}{{name}}) {
	return {{{classname}}}{{name}}(v.String())
}

func Parse{{{classname}}}{{name}}(str string, target *{{{classname}}}{{name}}) error {
	switch str {
	{{#allowableValues}}
	{{#enumVars}}
	case {{{value}}}:
		*target = {{>enums/model-prop-type-name}}{{#lambda.pascalcase}}{{{value}}}{{/lambda.pascalcase}}
	{{/enumVars}}
	{{/allowableValues}}
	default:
		return fmt.Errorf("unexpected {{{classname}}}{{name}} value: %s", str)
	}
	return nil
}

func (v *{{{classname}}}{{name}}) UnmarshalJSON(data []byte) error {
	var str string
	if err := json.Unmarshal(data, &str); err != nil {
		return err
	}
	return Parse{{{classname}}}{{name}}(str, v)
}

// All allowed values of {{{classname}}}{{name}} enum
var Allowed{{{classname}}}{{name}}Values = []{{{classname}}}{{name}}{
	{{#allowableValues}}
	{{#enumVars}}
	{{>enums/model-prop-type-name}}{{#lambda.pascalcase}}{{{value}}}{{/lambda.pascalcase}},
	{{/enumVars}}
	{{/allowableValues}}
}
